import os
import angr
import logging
import binascii

from textwrap import dedent

l = logging.getLogger("rex.exploit.exploit")

class ExploitException(Exception):
    pass

class Exploit(object):
    '''
    An Exploit object represents the successful application of an exploit technique to a crash state.
    The Exploit object encapsulates an exploited state.
    '''

    def __init__(self, crash, bypasses_nx, bypasses_aslr):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param bypasses_nx: does the exploit bypass NX?
        :param bypasses_aslr: does the exploit bypass ASLR?
        '''

        self.bypasses_nx = bypasses_nx
        self.bypasses_aslr = bypasses_aslr

        self.crash = crash
        self.binary = crash.binary
        self.project = crash.project

        self.exploit_state = crash.state

        self._script_string = None

    def _at_syscall(self, path):
        '''
        Is the current path at a syscall instruction? Will it make a syscall next step?
        :param path: the path to test
        :return: True if a syscall will be executed next step
        '''

        return self.project.factory.block(path.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def dump(self, filename=None):
        '''
        default behavior for payload dumper
        '''

        if not filename is None:
            self.exploit_state.posix.dump(0, filename)
        return self.exploit_state.posix.dumps(0)

    def script(self, filename):
        if self._script_string is None:
            self._script_string = self._write_script()
        with open(filename, 'w') as f:
            f.write(self._script_string)

    def _write_script(self):

        actions = [ ]

        path = self.crash.prev
        s = self.exploit_state

        last_action = None
        for a in path.history.actions.hardcopy + self.crash.added_actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                        continue

            if a.action == 'write':
                size = s.se.eval(a.size.ast)
                sval = s.se.eval(a.data.ast, cast_to=bytes)[:size]
                actions.append("r.readuntil(%r)" % sval)
                last_action = a.action

            if a.action == 'read':
                size = s.se.eval(a.size.ast)
                concrete = s.se.eval(a.data.ast, cast_to=bytes)[:size]
                if last_action == 'read':
                    actions.append('time.sleep(.1)')
                actions.append("r.send(%r)" % concrete)
                last_action = a.action

        body = '\n'.join(actions)

        preamble = """
import sys
import time
from pwn import *

if len(sys.argv) < 3:
    print "%s: <host> <port>" % sys.argv[0]
    sys.exit(1)

r = remote(sys.argv[1], int(sys.argv[2]))
"""

        tail = "\nr.interactive()\n"

        return preamble + body + tail

    def pov(self):
        '''
        Write out the exploit in DARPA's POV format.

        TODO: No value information is accounted for, this will almost always just cause the register to be the value of 0,
        PC to be 0, or the address to leak to be 0
        TODO: No rerandomization has occured at this time, the POV will act as though the target's randomness is fixed
        '''

        actions = [ ]
        path = self.crash.prev
        s = self.exploit_state

        for a in path.history.actions:
            if not isinstance(a, angr.state_plugins.SimActionData) or \
                    not (a.type.startswith('aeg_stdin') or a.type.startswith('file_/dev/stdout')):
                        continue

            if a.action == 'write':
                size = s.se.eval(a.size.ast)
                sval = s.se.eval(a.data.ast, cast_to=bytes)[:size]
                read_action = dedent("""\
                        <read>
                          <length>{}</length>
                          <data format="hex">{}</data>
                        </read>""").format(size, binascii.hexlify(sval).decode())
                actions.append(read_action)

            if a.action == 'read':
                size = s.se.eval(a.size.ast)
                sval = s.se.eval(a.data.ast, cast_to=bytes)[:size]
                write_action = dedent("""\
                        <write>
                          <data format="hex">{}</data>
                        </write>""").format(binascii.hexlify(sval).decode())
                actions.append(write_action)

        body = '\n'.join(actions)

        pov = dedent("""\
                <pov>
                  <cbid>{}</cbid>
                  <replay>
                {}
                  </replay>
                </pov>""").format(os.path.basename(self.binary), body)

        return pov

    def _windup_state(self, state, to_syscall=False):
        '''
        Windup the state to a desired point, by default an unconstrained successors. This is helpful
        for applying constraints after a ROP chain has executed or a system call is about to occur so
        constraints can further be applied to the states.
        :param state: the SimState to windup
        :param to_syscall: if we should stop at syscall opposed to an unconstrained successor
        :return: a new state woundup
        '''

        state.options.add(angr.options.BYPASS_UNSUPPORTED_SYSCALL)

        successors = self.project.factory.successors(state)
        if len(successors.flat_successors) + len(successors.unconstrained_successors) != 1:
            raise ExploitException("path does not get to a single succesor")
        if to_syscall and self._at_syscall(state):
            return state
        if len(successors.flat_successors) == 1:
            return self._windup_state(successors.flat_successors[0], to_syscall)
        if len(successors.unconstrained_successors) > 0:
            return successors.unconstrained_successors[0]

        raise ExploitException("state did not reach an unconstrained successor or make syscall")
